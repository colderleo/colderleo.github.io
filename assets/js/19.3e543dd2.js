(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{671:function(e,s,t){"use strict";t.r(s);var r=t(16),a=Object(r.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("https://www.zhihu.com/question/29918252")]),e._v(" "),t("p",[t("strong",[e._v("逻辑地址")]),e._v("经过分段单元转换为"),t("strong",[e._v("线性地址(也就是虚拟地址)")]),e._v("，线性地址经过分页单元映射为"),t("strong",[e._v("物理地址")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("以下讲解都是在 Intel 32 位下，并且以代码段为例 (之所以不讲 64 位是因为在 64-bit long mode 下分段直接被禁用了，内存完全平坦，没什么可以讲的...)")])]),e._v(" "),t("p",[e._v("在 Intel 平台下，逻辑地址(logical address)是 selector:offset 这种形式，selector 是 CS 寄存器的值，"),t("strong",[e._v("offset 是 EIP 寄存器的值")]),e._v("。如果用 selector 去 GDT( 全局描述符表 ) 里拿到 segment base address(段基址) 然后加上 offset(段内偏移)，这就得到了 linear address。我们把这个过程称作"),t("strong",[e._v("段式内存管理")]),e._v("。")]),e._v(" "),t("p",[e._v("如果再把 linear address 切成四段，用前三段分别作为索引去PGD、PMD、Page Table里查表，最终就会得到一个页表项(Page Table Entry)，那里面的值就是一页物理内存的起始地址，把它加上 linear address 切分之后第四段的内容(又叫页内偏移)就得到了最终的 physical address。我们把这个过程称作"),t("strong",[e._v("页式内存管理")]),e._v("。")]),e._v(" "),t("p",[e._v("问题来了，为什么没提到 virtual address，这是个什么东西？其实在 Intel IA-32 手册里并没有提到这个术语，但是在内核的确是用到了这个概念，比如__va和__pa这两个宏定义。经过我的考证，virtual address就是linear address的别名，俩词汇是一个意思，内核代码和我们编程中喜欢用virtual address这个术语，而Intel手册里只用linear address这个术语。")]),e._v(" "),t("p",[e._v("https://www.zhihu.com/question/290504400/answer/485124116")])])}),[],!1,null,null,null);s.default=a.exports}}]);