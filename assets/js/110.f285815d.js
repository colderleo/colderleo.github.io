(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{456:function(n,s,a){"use strict";a.r(s);var e=a(16),l=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[n._v("#")]),n._v(" 参考")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/stevenczp/p/7136416.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/stevenczp/p/7136416.html"),a("OutboundLink")],1)]),n._v(" "),a("p",[n._v("如果不用OS提供的mutex，我们该如何实现互斥锁？(不考虑重入的情况）")]),n._v(" "),a("h2",{attrs:{id:"naive-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#naive-lock"}},[n._v("#")]),n._v(" naive lock")]),n._v(" "),a("p",[n._v("最简单的想法是，搞一个volatile类型的共享变量flag，值可以是flase（无锁）或者true（有锁），竞争线程监听flag，一旦发现flag为false，那么尝试cas更新flag为true，更新成功则说明占有了这个锁，更新失败说明临界区已经被其他线程占领，继续监听flag并尝试更新。占有锁的线程退出的时候，将flag修改为false，表示释放锁。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    volatile boolean flag = false;\n\n    void lock() {\n        while (!cas(flag, false, true)) {//返回true：占锁成功，返回false：占锁失败，继续循环尝试\n\n        }\n    }\n\n    void unlock() {\n        flag = false;\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br")])]),a("p",[n._v("这样做有个问题是无法保证公平性，可能有的倒霉蛋空转了一辈子也无法cas成功，无法做到按竞争线程先来后到的次序占有锁。")]),n._v(" "),a("h2",{attrs:{id:"ticket-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ticket-lock"}},[n._v("#")]),n._v(" Ticket Lock")]),n._v(" "),a("p",[n._v("为了提供公平，有人发明了Ticket Lock")]),n._v(" "),a("p",[n._v("线程想要竞争某个锁，需要先领一张ticket，然后监听flag，发现flag被更新为手上的ticket的值了，才能去占领锁")]),n._v(" "),a("p",[n._v("就像是在医院看病一样，医生就是临界区，病人就是线程，病人挂了号领一张单子，单子上写了一个独一无二的号码，病人等的时候就看屏幕，屏幕上显示到自己的号码了，才能进去找医生。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    AtomicInteger ticket = new AtomicInteger(0);\n    volatile int flag = 0;\n\n    void lock() {\n        int my_ticket = ticket.getAndIncrement();//发号必须是一个原子操作，不能多个线程拿到同一个ticket\n        while (my_ticket != flag) {\n\n        }\n    }\n\n    void unlock() {\n        flag++;\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br")])]),a("p",[n._v("现在公平性的问题没有了，但是所有的线程都在监听flag变量，而且由于为了保证flag变量变化的可见性，它必须是volatile的。也就是说如果某个线程修改了flag变量，都会引起其他所有监听线程所在的core的对应于flag变量的cache line被设为invalid，那么这些线程下一次查询flag变量的时候，就必须从主存里取最新的flag数据了，由于主存带宽有限，这个开销较为昂贵（与监听线程数成正比）。")]),n._v(" "),a("h2",{attrs:{id:"clh-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clh-lock"}},[n._v("#")]),n._v(" CLH Lock")]),n._v(" "),a("p",[n._v("为了减少缓存一致性带来的开销，CLH Lock被发明了。")]),n._v(" "),a("p",[n._v("ps，CLH实际上是指三个人：Craig, Landin, and Hagersten")]),n._v(" "),a("p",[n._v("CLH锁的核心思想是，1. 竞争线程排队 2. 监听变量拆分")]),n._v(" "),a("p",[n._v("CLH锁维护了一个链表waitingList的head与tail，其节点定义如下：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    static class Node {\n        volatile boolean flag;//true：当前线程正在试图占有锁或者已经占有锁，false：当前线程已经释放锁，下一个线程可以占有锁了\n        Node prev;//监听前一个节点的flag字段\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("p",[n._v("初始时需要定义一个dummy节点（dummpy.flag == true, dummy.prev == null），head == tail == dummy")]),n._v(" "),a("p",[n._v("当有线程想要获取锁时，先创建一个链表节点node，然后将node挂载在waitingList的尾部（尝试cas(tail, oldTail, node)，如果成功将node.prev更新为oldTail，失败则重试）")]),n._v(" "),a("p",[n._v("然后这个线程就监听node.prev.flag，什么时候node.prev.flag == false了，说明node的前一个节点对应的线程已经释放了锁，本线程此时可以安全的占有锁了")]),n._v(" "),a("p",[n._v("释放锁的时候，将对应的node.flag修改为false即可。")]),n._v(" "),a("p",[n._v("实现代码如下（相当粗糙，意会即可）：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public class CLHLock {\n    volatile Node head, tail;//waitingList\n\n    public CLHLock() {\n        head = tail = Node.DUMMY;\n    }\n\n    public Node lock() {\n        //lock-free的将node添加到waitingList的尾部\n        Node node = new Node(true, null);\n        Node oldTail = tail;\n        while (!cas(tail, oldTail, node)) {\n            oldTail = tail;\n        }\n        node.setPrev(oldTail);\n\n        while (node.getPrev().isLocked()) {//监听前驱节点的locked变量\n        }\n\n        return node;\n    }\n\n    public void unlock(Node node) {\n        node.setLocked(false);\n    }\n\n    static class Node {\n        public Node(boolean locked, Node prev) {\n            this.locked = locked;\n            this.prev = prev;\n        }\n\n        volatile boolean locked;//true：当前线程正在试图占有锁或者已经占有锁，false：当前线程已经释放锁，下一个线程可以占有锁了\n        Node prev;//监听前一个节点的locked字段\n\n        public boolean isLocked() {\n            return locked;\n        }\n\n        public void setLocked(boolean locked) {\n            this.locked = locked;\n        }\n\n        public Node getPrev() {\n            return prev;\n        }\n\n        public void setPrev(Node prev) {\n            this.prev = prev;\n        }\n\n        public static final Node DUMMY = new Node(false, null);\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br"),a("span",{staticClass:"line-number"},[n._v("50")]),a("br"),a("span",{staticClass:"line-number"},[n._v("51")]),a("br"),a("span",{staticClass:"line-number"},[n._v("52")]),a("br"),a("span",{staticClass:"line-number"},[n._v("53")]),a("br"),a("span",{staticClass:"line-number"},[n._v("54")]),a("br")])]),a("p",[n._v("这样做可以极大的减少缓存一致性协议所带来的开销。")]),n._v(" "),a("p",[n._v("CLH锁的变种被应用于Java J.U.C包下的AbstractQueuedSynchronizer")]),n._v(" "),a("h2",{attrs:{id:"mcs锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mcs锁"}},[n._v("#")]),n._v(" MCS锁")]),n._v(" "),a("p",[n._v("CLH锁并不是完美的，因为每个线程都是在前驱节点的locked字段上自旋，而在NUMA体系中，有可能多个线程工作在多个不同的socket上的core里。如果前驱节点的内存跟监听线程的core距离过远，会有性能问题。")]),n._v(" "),a("p",[n._v("于是MCS锁诞生了")]),n._v(" "),a("p",[n._v("ps，MCS也是人名简写：John M. Mellor-Crummey and Michael L. Scott")]),n._v(" "),a("p",[n._v("MCS与CLH最大的不同在于："),a("strong",[n._v("CLH是在前驱节点的locked域上自旋，MCS是在自己节点上的locked域上自旋。")])]),n._v(" "),a("p",[n._v("具体的实现是，"),a("strong",[n._v("前驱节点在释放锁之后，会主动将后继节点的locked域更新。")])]),n._v(" "),a("p",[n._v("也就是把多次对远端内存的监听 + 一次对本地内存的更新，简化成了多次对本地内存的监听 + 一次对远端内存的更新。")]),n._v(" "),a("p",[n._v("具体的实现如下")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public class MCSLock {\n    volatile Node head, tail;//waitingList\n\n    public MCSLock() {\n        head = tail = null;\n    }\n\n    public Node lock() {\n        //lock-free的将node添加到waitingList的尾部\n        Node node = new Node(true, null);\n        Node oldTail = tail;\n        while (!cas(tail, oldTail, node)) {\n            oldTail = tail;\n        }\n\n        if (null == oldTail) {//如果等待列表为空，那么获取锁成功，直接返回\n            return node;\n        }\n\n        oldTail.setNext(node);\n        while (node.isLocked()) {//监听当前节点的locked变量\n        }\n\n        return node;\n    }\n\n    public void unlock(Node node) {\n        if (node.getNext() == null) {\n            if (cas(tail, node, null)) {//即使当前节点的后继为null，也要用cas看一下队列是否真的为空\n                return;\n            }\n            while (node.getNext() != null) {//cas失败，说明有后继节点，只是还没更新前驱节点的next域，等前驱节点看到后继节点后，即可安全更新后继节点的locked域\n\n            }\n        }\n        node.getNext().setLocked(false);\n    }\n\n    static class Node {\n        public Node(boolean locked, Node next) {\n            this.locked = locked;\n            this.next = next;\n        }\n\n        volatile boolean locked;//true：当前线程正在试图占有锁或者已经占有锁，false：当前线程已经释放锁，下一个线程可以占有锁了\n        Node next;//后继节点\n\n        public boolean isLocked() {\n            return locked;\n        }\n\n        public void setLocked(boolean locked) {\n            this.locked = locked;\n        }\n\n        public Node getNext() {\n            return next;\n        }\n\n        public void setNext(Node next) {\n            this.next = next;\n        }\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br"),a("span",{staticClass:"line-number"},[n._v("50")]),a("br"),a("span",{staticClass:"line-number"},[n._v("51")]),a("br"),a("span",{staticClass:"line-number"},[n._v("52")]),a("br"),a("span",{staticClass:"line-number"},[n._v("53")]),a("br"),a("span",{staticClass:"line-number"},[n._v("54")]),a("br"),a("span",{staticClass:"line-number"},[n._v("55")]),a("br"),a("span",{staticClass:"line-number"},[n._v("56")]),a("br"),a("span",{staticClass:"line-number"},[n._v("57")]),a("br"),a("span",{staticClass:"line-number"},[n._v("58")]),a("br"),a("span",{staticClass:"line-number"},[n._v("59")]),a("br"),a("span",{staticClass:"line-number"},[n._v("60")]),a("br"),a("span",{staticClass:"line-number"},[n._v("61")]),a("br"),a("span",{staticClass:"line-number"},[n._v("62")]),a("br"),a("span",{staticClass:"line-number"},[n._v("63")]),a("br")])]),a("p",[n._v("参考资料")]),n._v(" "),a("p",[a("a",{attrs:{href:"http://www.cnblogs.com/yuyutianxia/p/4296220.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("CLH锁 、MCS锁"),a("OutboundLink")],1)]),n._v(" "),a("p",[a("a",{attrs:{href:"http://www.ituring.com.cn/article/42394",target:"_blank",rel:"noopener noreferrer"}},[n._v("基于队列的锁:mcs lock简介"),a("OutboundLink")],1)]),n._v(" "),a("p",[a("a",{attrs:{href:"http://web.cecs.pdx.edu/~walpole/class/cs533/winter2011/slides/8b.pdf",target:"_blank",rel:"noopener noreferrer"}},[n._v("Spin Lock Performance"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=l.exports}}]);