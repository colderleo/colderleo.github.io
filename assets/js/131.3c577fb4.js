(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{634:function(s,t,n){"use strict";n.r(t);var e=n(16),a=Object(e.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"st-future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#st-future"}},[s._v("#")]),s._v(" st::future")]),s._v(" "),n("p",[n("a",{attrs:{href:"https://en.cppreference.com/w/cpp/thread/future",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://en.cppreference.com/w/cpp/thread/future"),n("OutboundLink")],1)]),s._v(" "),n("p",[s._v("The class template std::future provides a mechanism to access the result of asynchronous operations:")]),s._v(" "),n("ul",[n("li",[s._v("An asynchronous operation (created via std::async, std::packaged_task, or std::promise) can provide a std::future object to the creator of that asynchronous operation.")]),s._v(" "),n("li",[s._v("The creator of the asynchronous operation can then use a variety of methods to query, wait for, or extract a value from the std::future. These methods may block if the asynchronous operation has not yet provided a value.")]),s._v(" "),n("li",[s._v("When the asynchronous operation is ready to send a result to the creator, it can do so by modifying shared state (e.g. std::promise::set_value) that is linked to the creator's std::future.")])]),s._v(" "),n("p",[s._v("Note that std::future references shared state that is not shared with any other asynchronous return objects (as opposed to std::shared_future).")]),s._v(" "),n("h2",{attrs:{id:"std-promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-promise"}},[s._v("#")]),s._v(" std::promise")]),s._v(" "),n("p",[s._v("参考"),n("a",{attrs:{href:"https://blog.csdn.net/lijinqi1987/article/details/78507623",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://blog.csdn.net/lijinqi1987/article/details/78507623"),n("OutboundLink")],1)]),s._v(" "),n("p",[s._v("promise对象会承诺在将来赋值，它可以通过get_future()取出其对应的future对象，当该future对象调用get()时，如果promise对象还未被赋值，则future.get()会阻塞等待其被赋值。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("std::promise<int> promiseObj;\nstd::future<int> futureObj = promiseObj.get_future();\n\nint val = futureObj.get();//如果promise对象未赋值，此处将阻塞等待其赋值\n\n\n//例如在另一个线程中对poromise赋值：\npromiseObj.set_value(45);\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("promise"),n("T",[s._v("对象的T也可以是函数指针，同样可以取出其对应的future对象。当调用future.get()时，像上面一样，如果promise未被赋值，则future.get()会阻塞等待其被赋值。")])],1),s._v(" "),n("p",[n("strong",[s._v("注意get得到的是函数指针，并不是函数返回值。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <iostream>\n#include <future>\n#include <chrono>\n#include <functional>\n \n//声明一个可调对象T\nusing T = std::function<int(int)>;\t\t//等同于typedef std::function<int(int)> T;\n \nint Test_Fun(int iVal)\n{\n\tstd::cout << "Value is:" << iVal << std::endl;\n\treturn iVal + 232;\n}\n \nvoid Thread_Fun1(std::promise<T> &p)\n{\n\t//为了突出效果，可以使线程休眠5s\n\tstd::this_thread::sleep_for(std::chrono::seconds(5));\n \n\tstd::cout << "传入函数Test_Fun" << std::endl;\n \n\t//传入函数Test_Fun\n\tp.set_value(std::bind(&Test_Fun, std::placeholders::_1));\n}\n \nvoid Thread_Fun2(std::future<T> &f)\n{\n\t//阻塞函数，直到收到相关联的std::promise对象传入的数据\n\tauto fun = f.get();\t\t//iVal = 233\n \n\tint iVal = fun(1);\n \n\tstd::cout << "收到函数并运行，结果：" << iVal << std::endl;\n}\n \nint main()\n{\n\t//声明一个std::promise对象pr1，其保存的值类型为int\n\tstd::promise<T> pr1;\n\t//声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定\n\tstd::future<T> fu1 = pr1.get_future();\n \n\t//创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行\n\tstd::thread t1(Thread_Fun1, std::ref(pr1));\n\t//创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行\n\tstd::thread t2(Thread_Fun2, std::ref(fu1));\n \n\t//阻塞至线程结束\n\tt1.join();\n\tt2.join();\n \n\treturn 1;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br")])]),n("h2",{attrs:{id:"packaged-task"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#packaged-task"}},[s._v("#")]),s._v(" packaged_task")]),s._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/godmaycry/article/details/72868559",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://blog.csdn.net/godmaycry/article/details/72868559"),n("OutboundLink")],1)]),s._v(" "),n("p",[s._v("std::packaged_task和std::promise非常相似，简单来说std::packaged_task"),n("F",[s._v("是对std::promise<T= std::function"),n("F",[s._v(">中T= std::function"),n("F",[s._v("这一可调对象(如函数、lambda表达式等)进行了包装，简化了使用方法。并将这一可调对象的返回结果传递给关联的std::future对象。")])],1)],1)],1),s._v(" "),n("p",[s._v("或者说，packaged_task对象创建时传入的是函数，promise创建时传入的是函数类型。")]),s._v(" "),n("p",[n("strong",[s._v("注意其get_future是get到函数的返回值。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//函数\nint Test_Fun(int iVal)\n{\n    std::cout << "Value is:" << iVal << std::endl;\n    return iVal + 232;\n}\n \n//声明一个std::packaged_task对象pt1，包装函数Test_Fun\nstd::packaged_task<int(int)> pt1(Test_Fun);\n//声明一个std::future对象，包装Test_Fun的返回结果，并与pt1关联\nstd::future<int> fu1 = pt1.get_future();\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])])])}),[],!1,null,null,null);t.default=a.exports}}]);