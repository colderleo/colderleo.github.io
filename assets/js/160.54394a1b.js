(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{601:function(s,n,t){"use strict";t.r(n);var e=t(16),a=Object(e.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("https://www.cnblogs.com/nigang/p/3613452.html")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("CExample 是一个类，定义其拷贝构造函数和赋值运算符：\n\nCExample(const CExample& RightSides) //拷贝构造函数  \n\nCExample & CExample::operator = (const CExample& RightSides) //赋值操作符重载  \n\nCExample B=A; \t//这时会调用拷贝构造函数。 \nCExample B；\t//这时会调用默认构造函数 \nB=A;\t\t//这时会调用赋值运算符\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("拷贝构造函数何时被调用？")]),s._v(" "),t("p",[s._v("a.对象的直接赋值也会调用拷贝构造函数 ；")]),s._v(" "),t("p",[s._v("b.函数参数传递只要是按"),t("em",[s._v("值传递")]),s._v("也调用拷贝构造函数；")]),s._v(" "),t("p",[s._v("c.函数返回只要是按值返回也调用拷贝构造函数。(这里如果编译器开启了返回值优化，则不会调用拷贝构造函数，)")]),s._v(" "),t("p",[t("strong",[s._v("如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码。")])]),s._v(" "),t("p",[t("strong",[s._v("另外，当使用自定义类作为vector成员时，不能把拷贝构造函数声明为私有。")])])])}),[],!1,null,null,null);n.default=a.exports}}]);