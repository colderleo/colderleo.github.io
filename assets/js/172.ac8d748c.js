(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{593:function(s,n,a){"use strict";a.r(n);var e=a(16),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"字典使用时深层修改失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字典使用时深层修改失效"}},[s._v("#")]),s._v(" 字典使用时深层修改失效")]),s._v(" "),a("p",[s._v("参考："),a("a",{attrs:{href:"https://stackoverflow.com/questions/59752003/multiprocessing-manager-dict-update-failed",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://stackoverflow.com/questions/59752003/multiprocessing-manager-dict-update-failed"),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("如果直接更新深层的字典，会不起作用：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("manager = Manager()\npdict = manager.dict()\npdict['a'] = {'ss': 'init val'}\n\nprint('before: ', pdict)\npdict['a']['ss'] = 'something new'\nprint('after: ', pdict) #前后print出来都是一样的，修改未生效\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("可使用下面的上下文管理器：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class ProcessDictUpdate(object):\n    '''usage:\n        manager = Manager()\n        pdict = manager.dict()\n        pdict['a'] = {'ss': 'init val'}\n        \n        print('before: ', pdict)\n        with ProcessDictUpdate(pdict) as newd:\n            newd['a']['ss'] = 'something new'\n        print('after: ', pdict) #修改生效\n    '''\n    def __init__(self, process_dict, lock:multiprocessing.Lock=None):\n        if lock:\n            lock.acquire()\n        self.lock = lock\n        self.process_dict = process_dict\n        self.cp = copy.deepcopy(self.process_dict)\n\n    def __enter__(self):\n        return self.cp\n\n    def __exit__(self, exc_type, exc_value, exc_traceback_obj):\n        for key in self.cp:\n            self.process_dict[key] = self.cp[key]\n        if self.lock:\n            self.lock.release()\n        return True #程序继续执行\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br")])]),a("h3",{attrs:{id:"加锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁"}},[s._v("#")]),s._v(" 加锁")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://www.jb51.net/article/171299.htm",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.jb51.net/article/171299.htm"),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("python多进程和多线程是大家会重点了解的部分，因为很多工作如果并没有前后相互依赖关系的话其实顺序并不是非常的重要，采用顺序执行的话就必定会造成无谓的等待，任凭cpu和内存白白浪费，这是我们不想看到的。")]),s._v(" "),a("p",[s._v("为了解决这个问题，我们就可以采用多线程或者多进程的方式，（多线程我们之后再讲），而这两者之间是有本质区别的。就内存而言，已知进程是在执行过程中有独立的内存单元的，而多个线程是共享内存的，这是多进程和多线程的一大区别。")]),s._v(" "),a("p",[s._v("利用Value在不同进程中同步变量")]),s._v(" "),a("p",[s._v("在多进程中，由于进程之间内存相互是隔离的，所以无法在多个进程中用直接读取的方式共享变量，这时候就可以用multiprocessing库中的 Value在各自隔离的进程中共享变量。")]),s._v(" "),a("p",[s._v("下面是一个多进程的例子：")]),s._v(" "),a("p",[s._v("假设有一个counter用来记录程序经过的总循环次数，每调用一次count函数之后counter就会增加20，在主程序中用循环开10个进程分别调用count函数，那么理想状态下，在十个进程中共享的counter值到程序结束后应该是200。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("from multiprocessing import Process, Value\nimport time\n \ndef count(v):\n  for i in range(20):\n    time.sleep(0.01)\n    v.value += 1\n \ndef main():\n  value = Value('i',0)\n  processes = [Process(target=count, args=(value,)) for i in range(10)]\n \n  for p in processes:\n    p.start()\n  for p in processes:\n    p.join()\n \n  print(value.value)\n \nif __name__ == '__main__':\n \n  for i in range(10):\n    main()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br")])]),a("p",[s._v("运行这个例子，会得到怎样的结果呢？")]),s._v(" "),a("p",[s._v("188\n180\n168\n186\n183\n179\n186\n181\n166\n186")]),s._v(" "),a("p",[s._v("我在主程序里运行了十次这个程序，而最后的结果是160-180之间，总之，没有一次到200。这是什么原因呢？")]),s._v(" "),a("p",[s._v("相信很多人都已经明白了问题所在，那就是因为在multiprocessing库中的Value是细粒度的，Value中有一个ctypes类型的对象，拥有一个value属性来表征内存中实际的对象。Value可以保证同时只有一个单独的线程或进程在读或者写value值。这么看起来没有什么问题。")]),s._v(" "),a("p",[s._v("然而在第一个进程加载value值的时候，程序却不能阻止第二个进程加载旧的值。两个进程都会把value拷贝到自己的私有内存然后进行处理，并写回到共享值里。")]),s._v(" "),a("p",[s._v("那么这么会出现什么问题呢？")]),s._v(" "),a("p",[s._v("最后的共享值只接收到了一次值的增加，而非两次。")]),s._v(" "),a("p",[s._v("Python客栈送红包、纸质书")]),s._v(" "),a("p",[s._v("利用Lock在不同进程共享变量时加锁\n上面的问题其实可以用一个非常简单的方法解决，我们只需要调用multiprocessing库中的Lock （锁）就可以保证一次只能有一个进程访问这个共享变量。修改后的代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("from multiprocessing import Process, Value, Lock\nfrom time import sleep\n \ndef count(x,lock):\n  for i in range(20):\n    sleep(0.01)\n    with lock:\n      x.value += 1\n \n \ndef main():\n  counter = Value('i',0)\n  lock = Lock()\n  processes = [Process(target=count,args=(counter,lock)) for i in range(10)]\n  for p in processes:\n    p.start()\n  for p in processes:\n    p.join()\n \n  print(counter.value)\n \nif __name__ == '__main__':\n  for i in range(10):\n    main()\n    \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br")])]),a("p",[s._v("这样一来，输出的结果就会恒定为200了。")]),s._v(" "),a("p",[s._v("一些补充")]),s._v(" "),a("ol",[a("li",[s._v("调用get_lock() 函数\n其实Value这个包里已经包含了锁的概念，如果调用get_lock() 函数就可以自动给共享变量加锁。这样其实是比较推荐的方式，因为这样就不需要同时调用两个包。修改如下：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("from multiprocessing import Process, Value\nfrom time import sleep\n \ndef count(x):\n  for i in range(20):\n    global counter # 声明全局变量\n    sleep(0.01)\n    with counter.get_lock(): # 直接调用get_lock()函数获取锁\n      x.value += 1\n \ndef main():\n  processes = [Process(target=count, args=(counter,)) for i in range(10)]\n  for p in processes:\n    p.start()\n  for p in processes:\n    p.join()\n \n  print(counter.value)\n \nif __name__ == '__main__':\n  counter = Value('i', 0) # 需要把全局变量移到主程序\n  main()\n \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br")])]),a("p",[s._v("上面的程序更加明确，且最终结果也是200。")]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("使用 multiprocessing.RawValue\n整个multiprocessing包里刚刚调用的Value和Lock还可以统一被 multiprocessing.RawValue取代。")])])])}),[],!1,null,null,null);n.default=t.exports}}]);