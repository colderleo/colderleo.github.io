(window.webpackJsonp=window.webpackJsonp||[]).push([[293],{462:function(t,a,s){"use strict";s.r(a);var r=s(16),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h5",{attrs:{id:"文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文章"}},[t._v("#")]),t._v(" 文章")]),t._v(" "),s("p",[t._v("https://www.163.com/dy/article/GF8RI6NE0552D3ZX.html")]),t._v(" "),s("h5",{attrs:{id:"topk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#topk"}},[t._v("#")]),t._v(" TopK")]),t._v(" "),s("h5",{attrs:{id:"用两个栈实现一个队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用两个栈实现一个队列"}},[t._v("#")]),t._v(" 用两个栈实现一个队列")]),t._v(" "),s("h5",{attrs:{id:"stl中哪个容器遍历最快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stl中哪个容器遍历最快"}},[t._v("#")]),t._v(" stl中哪个容器遍历最快？")]),t._v(" "),s("p",[t._v("vector，因为内存连续，cache命中率高")]),t._v(" "),s("h5",{attrs:{id:"静态链接库和动态链接库的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态链接库和动态链接库的区别"}},[t._v("#")]),t._v(" 静态链接库和动态链接库的区别，")]),t._v(" "),s("h5",{attrs:{id:"so原理-dll原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#so原理-dll原理"}},[t._v("#")]),t._v(" so原理，，，，dll原理")]),t._v(" "),s("h5",{attrs:{id:"mysql优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql优化"}},[t._v("#")]),t._v(" mysql优化")]),t._v(" "),s("h5",{attrs:{id:"inline的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inline的特点"}},[t._v("#")]),t._v(" inline的特点")]),t._v(" "),s("h5",{attrs:{id:"socket-epoll-和select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#socket-epoll-和select"}},[t._v("#")]),t._v(" socket epoll 和select")]),t._v(" "),s("h5",{attrs:{id:"atomic底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#atomic底层实现"}},[t._v("#")]),t._v(" atomic底层实现")]),t._v(" "),s("p",[t._v("总线锁")]),t._v(" "),s("h5",{attrs:{id:"哪些资源是线程独有的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些资源是线程独有的"}},[t._v("#")]),t._v(" 哪些资源是线程独有的")]),t._v(" "),s("p",[t._v("std::thread_local相关")]),t._v(" "),s("p",[t._v("线程共享：进程代码段、进程的公有数据、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID；\n线程私有：线程ID、寄存器里的值、栈、线程的私有数据、线程的优先级、信号屏蔽码、错误返回码。")]),t._v(" "),s("h5",{attrs:{id:"大端小端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大端小端"}},[t._v("#")]),t._v(" 大端小端")]),t._v(" "),s("h5",{attrs:{id:"右值引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#右值引用"}},[t._v("#")]),t._v(" 右值引用")]),t._v(" "),s("h5",{attrs:{id:"堆排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[t._v("#")]),t._v(" 堆排序")]),t._v(" "),s("p",[t._v("https://www.jianshu.com/p/21bef3fc3030")]),t._v(" "),s("h5",{attrs:{id:"读写锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读写锁"}},[t._v("#")]),t._v(" 读写锁")]),t._v(" "),s("p",[t._v("具体实现")]),t._v(" "),s("h5",{attrs:{id:"字节对齐的好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字节对齐的好处"}},[t._v("#")]),t._v(" 字节对齐的好处")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("不同cpu的结构不一样，不对齐的话可能会出现数据不一致；")])]),t._v(" "),s("li",[s("p",[t._v("提高cpu读取效率：比如有些平台CPU从内存中偶数地址开始读取数据，如果数据起始地址正好为偶数，则1个读取周期就可以读出一个int类型的值，而如果数据其实地址为奇数，那我们就需要2个读取周期读出数据，并对高地址和低地址进行拼凑，这在读取效率上显然已经落后了很多了。")])])]),t._v(" "),s("h5",{attrs:{id:"cpu分支预测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu分支预测"}},[t._v("#")]),t._v(" cpu分支预测")]),t._v(" "),s("h5",{attrs:{id:"位运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[t._v("#")]),t._v(" 位运算")]),t._v(" "),s("p",[t._v("很多程序需要对n字节对齐，把a按n字节对齐的位运算为：(a + n - 1) & (~(n - 1))，即如果 qn < a <=(q+1)n, 则把a对齐到(q+1)n。注：这里的n需要是2的整数次方。")])])}),[],!1,null,null,null);a.default=e.exports}}]);