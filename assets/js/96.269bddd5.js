(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{467:function(e,a,r){"use strict";r.r(a);var s=r(16),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"缓存一致性协议mesi"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存一致性协议mesi"}},[e._v("#")]),e._v(" 缓存一致性协议MESI")]),e._v(" "),r("p",[e._v("参考： "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/123926004",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/123926004"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("不同cpu拥有各自的cache，cache读写的最小单位是cache line，一般是64字节。多个cache与内存之间的数据同步该怎么做？缓存一致性协议就是要解决这个问题，协议有多种，可以分为两类：“窥探（snooping）”协议和“基于目录的（directory-based）”协议，MESI协议属于一种“窥探协议“。")]),e._v(" "),r("p",[r("strong",[e._v("cache line的四种状态")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("Invalid，表明该cache line已失效，它要么已经不在cache中，要么它的内容已经过时。处于该状态下的cache line等同于它从来没被加载到cache中。")]),e._v(" "),r("li",[e._v("Shared，表明该cache line是内存中某一段数据的拷贝，处于该状态下的cache line只能被cpu读取，不能写入，因为此时还没有独占。不同cpu的cache line都可以拥有这段内存数据的拷贝。")]),e._v(" "),r("li",[e._v("Exclusive，和 Shared 状态一样，表明该cache line是内存中某一段数据的拷贝。区别在于，该cache line独占该内存地址，其他处理器的cache line不能同时持有它，如果其他处理器原本也持有同一cache line，那么它会马上变成“Invalid”状态。")]),e._v(" "),r("li",[e._v("Modified，表明该cache line已经被修改，cache line只有处于Exclusive状态才能被修改。此外，已修改cache line如果被丢弃或标记为Invalid，那么先要把它的内容回写到内存中。")])]),e._v(" "),r("p",[e._v("我们发现，cpu有读取数据的动作，有独占的动作，有独占后更新数据的动作，有更新数据之后回写内存的动作，根据”窥探协议“的规范，每个动作都需要通知到其他cpu，于是有以下的"),r("strong",[e._v("消息机制")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("Read，cpu发起读取数据请求，请求中包含需要读取的数据地址。")]),e._v(" "),r("li",[e._v("Read Response，作为Read消息的响应，该消息可能是内存响应的，也可能是某cpu响应的(比如该地址在某cpu cache Line中为Modified状态，则该cpu必须返回该地址的最新数据)。")]),e._v(" "),r("li",[e._v("Invalidate，cpu发起”我要独占一个cache line，其他cpu请失效对应的cache line“的消息，消息中包含了内存地址，所有的其它cpu需要将对应cache line置为Invalid状态。")]),e._v(" "),r("li",[e._v("Invalidate ACK，收到Invalidate消息的cpu在将对应cache line置为Invalid后，返回Invalid ACK。")]),e._v(" "),r("li",[e._v("Read Invalidate，相当于Read消息+Invalidate消息，即取得数据并且独占它，将收到一个Read Response和所有其它cpu的Invalidate ACK。")]),e._v(" "),r("li",[e._v("Write back，写回消息，即将状态为Modified的cache line写回到内存，通常在该行将被替换时使用。现代cpu cache基本都采用”写回(Write Back)”而非”直写(Write Through)”的方式。")])]),e._v(" "),r("p",[e._v("在MESI协议下工作即可保证各cpu之间的cache一致。不过cpu如果每次访问数据cache都经过MESI协议，太慢了，于是又增加了store buffer和invalid queue来加速。")]),e._v(" "),r("h2",{attrs:{id:"sotre-buffer和invalid-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sotre-buffer和invalid-queue"}},[e._v("#")]),e._v(" sotre buffer和invalid queue")]),e._v(" "),r("p",[e._v("参考： "),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/125549632",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/125549632"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"store-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#store-buffer"}},[e._v("#")]),e._v(" store buffer")]),e._v(" "),r("p",[e._v("![img](03.memory order 内存模型，reorder，memory_order_acquire - C++.assets/v2-3f2d67d49f22f0d23ccac160b27a52b1_720w.jpg)")]),e._v(" "),r("p",[e._v("每个cpu内部增加一个store buffer，"),r("strong",[e._v("写数据")]),e._v("的时候先写到store buffer里，其他cpu看不到。等需要的时候再写到cache line中，同时通知其他cpu，使该cache line的内容对其他cpu可见。")]),e._v(" "),r("blockquote",[r("p",[e._v("程序员可以手动增加 Store Barrior 来将数据从store buffer刷到cache line中，从而使该数据对其他线程可见。")])]),e._v(" "),r("h4",{attrs:{id:"invalid-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#invalid-queue"}},[e._v("#")]),e._v(" invalid queue")]),e._v(" "),r("p",[e._v("但是仅有store buffer还不够，因为store buffer比较小，很容易满。当需要写到cache line的时候要通知其他cpu这个cache line  invalid了，然后等所有cpu回复invalid ack，才能继续往下走。其他cpu回复invalid ack之前要把对应的cache line状态改为invaid，这个操作比较耗时。怎么办呢，就是增加一个invalid queue。cpu在收到invalid消息时，把它放进invalid queue中，然后就回复invalid ack了，而invalid queue可以后续处理。")]),e._v(" "),r("blockquote",[r("p",[e._v("程序员可以手动增加 Load Barrier 将invalid queue中的数据读入cache line，从而获取其他线程对数据的修改。")])]),e._v(" "),r("h2",{attrs:{id:"编译器屏障和内存屏障"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编译器屏障和内存屏障"}},[e._v("#")]),e._v(" 编译器屏障和内存屏障")]),e._v(" "),r("h4",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考：")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43526907",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/43526907"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"编译器屏障"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编译器屏障"}},[e._v("#")]),e._v(" 编译器屏障")]),e._v(" "),r("p",[e._v("阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。（另一个重排是执行时的cpu指令重排，对应下面的内存屏障）")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('#define barrier() __asm__ __volatile__("": : :"memory") \n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("h4",{attrs:{id:"内存屏障"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[e._v("#")]),e._v(" 内存屏障")]),e._v(" "),r("p",[e._v("![img](03.memory order 内存模型，reorder，memory_order_acquire - C++.assets/v2-326ce3092f7c80cb4b20177724cdc8e4_720w-16345252611502.jpg)")]),e._v(" "),r("p",[e._v("Intel提供三种内存屏障指令：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("sfence ，实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他cpu核可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见；")])]),e._v(" "),r("li",[r("p",[e._v("lfence ，实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见性）；")])]),e._v(" "),r("li",[r("p",[e._v("mfence ，实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见；")])]),e._v(" "),r("li",[r("p",[e._v("lock 用来修饰当前指令操作的内存只能由当前CPU使用，若指令不操作内存仍然有用，因为这个修饰会让指令操作本身原子化，而且自带Full Barrior效果；还有指令比如IO操作的指令、exch等原子交换的指令，任何带有lock前缀的指令以及CPUID等指令都有内存屏障的作用。")])])]),e._v(" "),r("p",[e._v("GNU中的三种内存屏障定义方法，结合了编译器屏障和三种CPU屏障指令：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('#define lfence() __asm__ __volatile__("lfence": : :"memory") \n#define sfence() __asm__ __volatile__("sfence": : :"memory") \n#define mfence() __asm__ __volatile__("mfence": : :"memory") \n')])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("p",[e._v("C++11为内存屏障提供了专门的函数std::atomic_thread_fence，方便移植统一行为而且可以配合内存模型进行设置，比如实现Acquire-release语义。原子变量的使用相当于附带了该功能。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("#include <atomic>\nstd::atomic_thread_fence(std::memory_order_acquire);\nstd::atomic_thread_fence(std::memory_order_release);\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("h2",{attrs:{id:"c-memory-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-memory-order"}},[e._v("#")]),e._v(" C++ Memory Order")]),e._v(" "),r("h4",{attrs:{id:"参考-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考-2"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("p",[e._v("如何理解 C++11 的六种 memory order： "),r("a",{attrs:{href:"https://www.zhihu.com/question/24301047/answer/1193956492",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.zhihu.com/question/24301047/answer/1193956492"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"什么是原子操作、什么是memory-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是原子操作、什么是memory-order"}},[e._v("#")]),e._v(" 什么是原子操作、什么是Memory Order")]),e._v(" "),r("p",[r("strong",[e._v("原子操作就是对一个内存上变量（或者叫左值）的读取-变更-存储（load-add-store）作为一个整体一次完成。")]),e._v(" （即上文中的从cache line读写是一个整体）")]),e._v(" "),r("p",[e._v("各种memory order是对本线程上下文的约束。对于relaxed操作，就是只约束自身，不约束上下文。")]),e._v(" "),r("h4",{attrs:{id:"x86-memory-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#x86-memory-order"}},[e._v("#")]),e._v(" x86 Memory Order")]),e._v(" "),r("p",[e._v("评论里有很多关于"),r("strong",[e._v("x86内存模型")]),e._v("的指正，放在这里：（英特尔的官方文档可查）")]),e._v(" "),r("blockquote",[r("p",[e._v("Loads are not reordered with other loads.Stores are not reordered with other stores.Stores are not reordered with older loads.")])]),e._v(" "),r("p",[e._v("然后最重要的：")]),e._v(" "),r("blockquote",[r("p",[e._v("Loads may be reordered with older stores to different locations.")])]),e._v(" "),r("p",[e._v("因为 store-load 可以被重排，所以x86不是顺序一致。但是因为其他三种读写顺序不能被重排，所以x86是 acquire/release 语义。")]),e._v(" "),r("p",[e._v("aquire语义：load 之后的读写操作无法被重排至 load 之前。即 load-load, load-store 不能被重排。")]),e._v(" "),r("p",[e._v("release语义：store 之前的读写操作无法被重排至 store 之后。即 load-store, store-store 不能被重排。")]),e._v(" "),r("p",[e._v("最简单的试试 relaxed ordering 的方法就是拿出手机。写个小程序，故意留个 race condition，然后放到 iPhone 或者安卓手机上调，不用 release -- acquire 保准出错。然而这种 bug 你在 x86 的 host 机上是调不出来的，"),r("strong",[e._v("即便拿模拟器也调不出来")]),e._v("。")]),e._v(" "),r("p",[e._v("（貌似x86的Sotre Buffer是FIFO，所以store-store不能被重排）")]),e._v(" "),r("h2",{attrs:{id:"读写关系举例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读写关系举例"}},[e._v("#")]),e._v(" 读写关系举例")]),e._v(" "),r("p",[e._v("C++里的memory order是用来指定原子操作（atomic operation）和同线程内其他非原子操作之间的执行顺序的。")]),e._v(" "),r("h4",{attrs:{id:"sequential-consistency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sequential-consistency"}},[e._v("#")]),e._v(" Sequential Consistency")]),e._v(" "),r("p",[r("code",[e._v("memory_order_seq_cst")]),e._v("，即顺序一致性模型。")]),e._v(" "),r("h4",{attrs:{id:"acquire-release-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#acquire-release-模式"}},[e._v("#")]),e._v(" Acquire-Release 模式")]),e._v(" "),r("p",[r("code",[e._v("memory_order_release")]),e._v("前面不会被reorder到本句之后；"),r("code",[e._v("memory_order_acquire")]),e._v("之后的代码不会被reorder到本句之前；"),r("code",[e._v("memory_order_acq_rel")]),e._v("同时包含acquire和release标志。")]),e._v(" "),r("p",[e._v("这是一段实践代码，代码简单明确：https://www.cnblogs.com/lizhanzhe/p/10893016.html （里面关于relaxed部分的描述有一些问题）")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("#include <thread>\n#include <chrono>\n#include <mutex>\n#include <thread>\n#include <assert.h>\n#include <atomic>\n\nstd::atomic<int> a=0, b=0, c = 0;\n\nvoid t1_fun() {\n    a = 1;\n    b.store(2, std::memory_order_relaxed); //relaxed，松散的\n    \n    //memory_order_release，类似于mutex的unlock，自身线程中它之前的读写语句都会执行完，不会被优化到本句之后\n    c.store(3, std::memory_order_release);\n    \n}\nvoid t2_fun() {\n    //memory_order_acquire， 类似于mutex的lock，自身线程它后面的读写语句一定是在后面执行的，不会被优化到本句之前\n    while (c.load(std::memory_order_acquire) != 3); // 以下 assert 永远不会失败，因为t1_fun中，a、b赋值完之后才会给c赋值。\n    assert(a == 1 && b == 2);\n    assert(b.load(std::memory_order_relaxed) == 2);\n}\nint main() {\n    std::thread t1(t1_fun);\n    std::thread t2(t2_fun);\n    t1.join();\n    t2.join();\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br"),r("span",{staticClass:"line-number"},[e._v("15")]),r("br"),r("span",{staticClass:"line-number"},[e._v("16")]),r("br"),r("span",{staticClass:"line-number"},[e._v("17")]),r("br"),r("span",{staticClass:"line-number"},[e._v("18")]),r("br"),r("span",{staticClass:"line-number"},[e._v("19")]),r("br"),r("span",{staticClass:"line-number"},[e._v("20")]),r("br"),r("span",{staticClass:"line-number"},[e._v("21")]),r("br"),r("span",{staticClass:"line-number"},[e._v("22")]),r("br"),r("span",{staticClass:"line-number"},[e._v("23")]),r("br"),r("span",{staticClass:"line-number"},[e._v("24")]),r("br"),r("span",{staticClass:"line-number"},[e._v("25")]),r("br"),r("span",{staticClass:"line-number"},[e._v("26")]),r("br"),r("span",{staticClass:"line-number"},[e._v("27")]),r("br"),r("span",{staticClass:"line-number"},[e._v("28")]),r("br"),r("span",{staticClass:"line-number"},[e._v("29")]),r("br")])]),r("h4",{attrs:{id:"release-consume-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#release-consume-模式"}},[e._v("#")]),e._v(" Release-Consume 模式")]),e._v(" "),r("p",[r("code",[e._v("memory_order_consume")]),e._v("，"),r("strong",[e._v("只对当前要读取的内容施加acquire")]),e._v("，在代码中这条语句后面所有与这块内存有关的读写操作都无法被重排到这个操作之前。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("a = 0;\nc = 0;\nthread 1:{\n    a = 1; \n    c.store(3, memory_order_release);\n}\nthread 2:{ \n    //consume只约束本对象的memory order，不约束上下文中其他变量\n    while (c.load(memory_order_consume) != 3) ; \n    assert(a == 1); // assert 可能失败\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br")])]),r("h4",{attrs:{id:"relaxed模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#relaxed模式"}},[e._v("#")]),e._v(" Relaxed模式")]),e._v(" "),r("p",[e._v("松散的，不约束上下文其他变量的重排。对于一个"),r("code",[e._v("atomic<int> a;")]),e._v(" relaxed是它对别人relaxd，对自己是atomic的，也就是一个atomic操作，从cache line中读取、修改、写入这一套是不被分割的。")]),e._v(" "),r("p",[e._v("有文章说  “memory_order_relaxed: 只保证当前操作的原子性，不考虑线程间的同步，其他线程可能读到新值，也可能读到旧值。比如 C++ shared_ptr 里的引用计数，我们只关心当前的应用数量，而不关心谁在引用谁在解引用。”  这个说法有问题。一个atomic变量写时用relaxed，其他线程中读或者修改时会读到新值，因为atomic relax写时会写到cache line，另一个线程读时也会从cache line读。")]),e._v(" "),r("h2",{attrs:{id:"常见内存模型-概念上的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见内存模型-概念上的"}},[e._v("#")]),e._v(" 常见内存模型（概念上的）")]),e._v(" "),r("ul",[r("li",[e._v("参考: "),r("a",{attrs:{href:"https://www.cnblogs.com/miaolong/p/12574481.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/miaolong/p/12574481.html"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("Sequential Consistency 顺序一致性，简称SC")]),e._v(" "),r("li",[e._v("Total Store Ordering, 全存储排序，简称TSO")]),e._v(" "),r("li",[e._v("Relaxed memory models，松弛型内存模型")]),e._v(" "),r("li",[e._v("还有一些其他的各种各样的内存模型： Processor Consistency、Partial Consistency Ordering (PSO)、Weak Consistency、Release Consistency、Data-Race-Free-0 等待")])])])}),[],!1,null,null,null);a.default=t.exports}}]);